/*** 2025-08-23 ***/
Hello!
This is going to be an explaination of what this is! this is mainly for me, but I find that writing things down is very important in the nature of learning.
I will be updating this on what portion of the code we are at!!!
In the dotted lines we have the first boilderplate introduction to sqlite, which is a representation of SQLite, a widely used database engine.
Database: A system that store data in an organized way! (Tables, rows and columns)
SQLite: A small, fast, self-contained SQL database engine that:
    1.Runs inside your app (no seperate server needed),
    2.Uses a single file to store the whole database
    3.Very portable
It's used pretty much everywhere, IOS,Firefox,Chrome.

As of below we have a car, you can turn it on and it will start, but there is no gas pedal, any type of fuctionality is missing as of now.
No commands work, you can only exit and start it.

As I go, I won't be explaining every line of code, I don't have to define what a struct is in C
Or why I serialize/deserialize rows and why there is a function for that

/*** 2025-08-25 ***/
We have now added some interesting features so this very simple database. As of now we only insert id's Usernames, and emails which looks like this 
column	size (bytes)  offset
id	      4	            0
username  32	 		4
email	  255			36
total	  291

Our page size right now is only 4 kilobytes, it's the same size as a page used in the virtual memory of most computer architectures. Meaning one page in our database
corresponds to one page used by the operating system.
The plan so far is to:
    Store rows in blocks of memory called pages
    Each page stores as many rows as it can fit
    Rows are serialized into a compact representation with each page
    Pages are only allocated as needed
    Keep a fixed-size array of pointers to pages

```
const uint32_t PAGE_SIZE = 4096;
const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

typedef struct {
	uint32_t num_rows;
	void* pages[TABLE_MAX_PAGES];
} Table;
```

Preparing our statements no longer uses scanf() which could cause a buffer overflow if the string
it's reading is larger than the buffer it's reading into. Strtok() fixes this issue in our prepare_insert() function
Calling strtok successively on the input buffer breaks it into substrings by inserting a null character whenever it reaches a delimiter (space, in our case). It returns a pointer to the start of the substring.

We can call strlen() on each text value to see if it’s too long.
```
PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement){
    statement->type = STATEMENT_INSERT;

    char* keyword = strtok(input_buffer->buffer, " ");
    char* id_string = strtok(NULL, " " );
    char* username = strtok(NULL," ");
    char* email = strtok(NULL, " ");

    if(id_string = NULL || username == NULL || email == NULL){
        return PREPARE_SYNTAX_ERROR;
    }

    int id = atoi(id_string);
    if(id<0){
        return PREPARE_NEGATIVE_ID;
    }
    if(strlen(email) > COLUMN_EMAIL_SIZE) {
        return PREPARE_STRING_TOO_LONG;
    }

    statement->row_to_insert.id = id;
    strcpy(statment->row_to_insert.username,username);
    strcpy(statment->row_to_insert.email,email);

    return PREPARE_SUCCESS
}
```

We also have our SYNTAX ERROR HANDLER, still better than java.
Side tangent, why can't we just stay in C? why does everything in Java need to be so repetitive.
also EVERYTHING is a class (except for when it's not) I feel like im tip toeing around a problem when I code in java wheras in C it's like all meat no filler, delicious

I only complain about java when I don't have to maintain any code, I'm not building enterprise-scale applications lol
```
Statement statement;
	switch(prepare_statement(input_buffer, &statement)){
		case(PREPARE_SUCCESS):
			break;
        case(PREPARE_NEGATIVE_ID):
            printf("ID must be positive.\n");
            continue;
        case(PREPARE_STRING_TOO_LONG):
            printf("String is too long.\n");
            continue;
		case(PREPARE_SYNTAX_ERROR):
			printf("Syntax error. Could not parse statement.");
			continue;
		case(PREPARE_UNRECOGNIZED_STATEMENT):
			printf("Unrecognized keyword at start of '%s'.\n", input_buffer->buffer);
			continue;
	}
```
Now we will talk about spec_helper, some ruby tests that are written up so I don't have to keep testing the code
it's pretty readable, (like python, except when its not) I won't go in depth
```
describe 'database' do
  def run_script(commands)
    raw_output = nil
    IO.popen("./db", "r+") do |pipe|
      commands.each do |command|
        pipe.puts command
      end

      pipe.close_write

      # Read entire output
      raw_output = pipe.gets(nil)
    end
    raw_output.split("\n")
  end

  it 'inserts and retrieves a row' do
    result = run_script([
      "insert 1 user1 person1@example.com",
      "select",
      ".exit",
    ])
    expect(result).to match_array([
      "db > Executed.",
      "db > (1, user1, person1@example.com)",
      "Executed.",
      "db > ",
    ])
  end
```
Implementing a B-tree in this database. As of now we aren't using them, which is causing some headaches with memory management
Using a B-Tree is faster (log time), inserting/deleting a value you've already found is fast, and traversing a range of values it fast
(unless the tree is not a B-Tree in which it could resemble a linked list which is O(n) time to traverse)
 	Unsorted Array of rows	Sorted Array of rows	Tree of nodes
Pages contain	only data	only data	metadata, primary keys, and data
Rows per page	more	more	fewer
Insertion	O(1)	O(n)	O(log(n))
Deletion	O(n)	O(n)	O(log(n))
Lookup by id	O(n)	O(log(n))	O(log(n))

Implementation could be an array (slow for insertions) so lets use a tree structure for that juice O(log(n)) time!
Only thing is we can't use a binary search to find values because not an array. 

Leaf nodes and internal nodes have different layouts. Let’s make an enum to keep track of node type:
```
typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;
```

To Reiterate, the Pager is an abstraction that when asked for page number x, the pager gives us back
a block of memory. First looking in the cache then on cache miss copies from the disk to memory

Each node will correspond to one page. Internal nodes will point to their children by storing the page number that stores the child. 
The btree asks the pager for a particular page number and gets back a pointer into the page cache. 
Pages are stored in the database file one after the other in order of page number.

Nodes need to store some metadata in a header at the beginning of the page. 
Every node will store what type of node it is, whether or not it is the root node, 
and a pointer to its parent (to allow finding a node’s siblings). 
I define constants for the size and offset of every header field:



```
/* Common Node Layout */
/* Each node corresponds to one page, Internal nodes point to children by storing the page number that store the child
   The btree asks the pager for partic page number and gets back a pointer into the page cache. Pages are stored 
   in the databse file one after theo ther in order of page number.*/

/*Nodes need to store some metadata in a header at the beginning of the page.*/
const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);
const uint32_t NODE_TYPE_OFFSET = 0;
const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);
const uint32_t IS_ROOT_OFFSET = sizeof( NODE_TYPE_SIZE);
const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);
const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;
const uint8_t COMMON_NODE_HEADER_SIZE = NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;


/* Leaf Node Header Layout */
/* Leaf nodes also need to store how many "cells' they contrain. A cell is a key/value pair"*/
const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
const uint32_t LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;

/* Leaf Node Body Layout */
const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);
const uint32_t LEAF_NODE_KEY_OFFSET = 0;
const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;
const uint32_t LEAF_NODE_VALUE_OFFSET =
    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;
const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;
const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;
const uint32_t LEAF_NODE_MAX_CELLS =
    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;
```
Based on these constants, here's what the layout of a leaf node looks like currently
leaf-node-format.png

Now I'm sure you all read through and saw my rant with java earlier but I will admit, this is
where Java shines, why create getters/setters in the same file, why not just create a tree class
that stores all this information and create an object in the db.java file, where everything is all
neat and abstracted from the user, well because C doesn't have that functionality unfortunately. Anyways...

